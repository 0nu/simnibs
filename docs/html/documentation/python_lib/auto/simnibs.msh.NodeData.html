
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>simnibs.msh.NodeData &#8212; SimNIBS 3.0.0 documentation</title>
    <link rel="stylesheet" href="../../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="simnibs.msh.ElementData" href="simnibs.msh.ElementData.html" />
    <link rel="prev" title="simnibs.msh.Elements" href="simnibs.msh.Elements.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="simnibs-msh-nodedata">
<h1>simnibs.msh.NodeData<a class="headerlink" href="#simnibs-msh-nodedata" title="Permalink to this headline">¶</a></h1>
<dl class="class">
<dt id="simnibs.msh.NodeData">
<em class="property">class </em><code class="descclassname">simnibs.msh.</code><code class="descname">NodeData</code><span class="sig-paren">(</span><em>value</em>, <em>name=''</em>, <em>mesh=None</em><span class="sig-paren">)</span><a class="headerlink" href="#simnibs.msh.NodeData" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">simnibs.msh.mesh_io.Data</span></code></p>
<p>Data (scalar, vector or tensor) defined in mesh nodes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>value</strong> (<em>ndarray</em>) – <dl class="docutils">
<dt>Value of field in nodes. Should have the shape</dt>
<dd><ul class="first last">
<li>(n_nodes,) or (n_nodes, 1) for scalar fields</li>
<li>(n_nodes, 3) for vector fields</li>
<li>(n_nodes, 9) for tensors</li>
</ul>
</dd>
</dl>
</li>
<li><strong>field_name</strong> (<em>str</em><em> (</em><em>optional</em><em>)</em>) – name of field. Default: ‘’</li>
<li><strong>mesh</strong> (<a class="reference internal" href="simnibs.msh.Msh.html#simnibs.msh.Msh" title="simnibs.msh.Msh"><em>simnibs.msh.Msh</em></a><em> (</em><em>optinal</em><em>)</em>) – Mesh where the field is defined. Required for many methods</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="simnibs.msh.NodeData.value">
<code class="descname">value</code><a class="headerlink" href="#simnibs.msh.NodeData.value" title="Permalink to this definition">¶</a></dt>
<dd><p>Value of field in elements</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body">ndarray</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="simnibs.msh.NodeData.field_name">
<code class="descname">field_name</code><a class="headerlink" href="#simnibs.msh.NodeData.field_name" title="Permalink to this definition">¶</a></dt>
<dd><p>name of field</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body">str</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="simnibs.msh.NodeData.node_number">
<code class="descname">node_number</code><a class="headerlink" href="#simnibs.msh.NodeData.node_number" title="Permalink to this definition">¶</a></dt>
<dd><p>index of elements</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body">ndarray</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="simnibs.msh.NodeData.nr">
<code class="descname">nr</code><a class="headerlink" href="#simnibs.msh.NodeData.nr" title="Permalink to this definition">¶</a></dt>
<dd><p>number of data points</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body">property</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="simnibs.msh.NodeData.nr_comp">
<code class="descname">nr_comp</code><a class="headerlink" href="#simnibs.msh.NodeData.nr_comp" title="Permalink to this definition">¶</a></dt>
<dd><p>number of dimensions per data point (1 for scalars, 3 for vectors)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body">property</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="simnibs.msh.NodeData.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>value</em>, <em>name=''</em>, <em>mesh=None</em><span class="sig-paren">)</span><a class="headerlink" href="#simnibs.msh.NodeData.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#simnibs.msh.NodeData.__init__" title="simnibs.msh.NodeData.__init__"><code class="xref py py-obj docutils literal notranslate"><span class="pre">__init__</span></code></a>(value[,&nbsp;name,&nbsp;mesh])</td>
<td>Initialize self.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#simnibs.msh.NodeData.angle" title="simnibs.msh.NodeData.angle"><code class="xref py py-obj docutils literal notranslate"><span class="pre">angle</span></code></a>([fill])</td>
<td>Calculate the angle between the field and the surface normal</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#simnibs.msh.NodeData.append_to_mesh" title="simnibs.msh.NodeData.append_to_mesh"><code class="xref py py-obj docutils literal notranslate"><span class="pre">append_to_mesh</span></code></a>(fn[,&nbsp;mode])</td>
<td>Appends this NodeData fields to a file</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#simnibs.msh.NodeData.as_nodedata" title="simnibs.msh.NodeData.as_nodedata"><code class="xref py py-obj docutils literal notranslate"><span class="pre">as_nodedata</span></code></a>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#simnibs.msh.NodeData.calc_flux" title="simnibs.msh.NodeData.calc_flux"><code class="xref py py-obj docutils literal notranslate"><span class="pre">calc_flux</span></code></a>([nodes])</td>
<td>Calculates the flux of a vector field though the given nodes</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#simnibs.msh.NodeData.get_focality" title="simnibs.msh.NodeData.get_focality"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_focality</span></code></a>([cuttofs,&nbsp;peak_percentile])</td>
<td>Caluclates field focality as the area/volume of the mesh experiencing a field norm of above (cut_off% of the field peak).</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#simnibs.msh.NodeData.get_percentiles" title="simnibs.msh.NodeData.get_percentiles"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_percentiles</span></code></a>([percentile,&nbsp;roi])</td>
<td>Get percentiles of field (or field norm, if a vector field)</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#simnibs.msh.NodeData.gradient" title="simnibs.msh.NodeData.gradient"><code class="xref py py-obj docutils literal notranslate"><span class="pre">gradient</span></code></a>()</td>
<td>Calculates the gradient of a field in the middle of the tetrahedra</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#simnibs.msh.NodeData.interpolate_scattered" title="simnibs.msh.NodeData.interpolate_scattered"><code class="xref py py-obj docutils literal notranslate"><span class="pre">interpolate_scattered</span></code></a>(points[,&nbsp;out_fill,&nbsp;…])</td>
<td>Interpolates the NodeaData into the points by finding the element containing the point and performing linear interpolation inside the element</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#simnibs.msh.NodeData.interpolate_to_grid" title="simnibs.msh.NodeData.interpolate_to_grid"><code class="xref py py-obj docutils literal notranslate"><span class="pre">interpolate_to_grid</span></code></a>(n_voxels,&nbsp;affine,&nbsp;**kwargs)</td>
<td>Interpolates the NodeData into a grid.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#simnibs.msh.NodeData.interpolate_to_surface" title="simnibs.msh.NodeData.interpolate_to_surface"><code class="xref py py-obj docutils literal notranslate"><span class="pre">interpolate_to_surface</span></code></a>(surface[,&nbsp;out_fill])</td>
<td>Interpolates the field in the nodes of a given surface The interpolation occurs in the tetrahedra!</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#simnibs.msh.NodeData.mean_field_norm" title="simnibs.msh.NodeData.mean_field_norm"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mean_field_norm</span></code></a>()</td>
<td>Calculates V*w/sum(w) Where V is the norm of the field, and w is the volume or area of the mesh where the field is defined.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#simnibs.msh.NodeData.node_data2elm_data" title="simnibs.msh.NodeData.node_data2elm_data"><code class="xref py py-obj docutils literal notranslate"><span class="pre">node_data2elm_data</span></code></a>()</td>
<td>Transforms an ElementData field into a NodeData field the value in the element is the average of the value in the nodes</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#simnibs.msh.NodeData.norm" title="simnibs.msh.NodeData.norm"><code class="xref py py-obj docutils literal notranslate"><span class="pre">norm</span></code></a>([ord])</td>
<td>Calculate the norm of the field</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#simnibs.msh.NodeData.normal" title="simnibs.msh.NodeData.normal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">normal</span></code></a>([fill])</td>
<td>Calculate the normal component of the field in the mesh surfaces</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#simnibs.msh.NodeData.read_hdf5_data_matrix_row" title="simnibs.msh.NodeData.read_hdf5_data_matrix_row"><code class="xref py py-obj docutils literal notranslate"><span class="pre">read_hdf5_data_matrix_row</span></code></a>(leadfield_fn,&nbsp;…)</td>
<td>Reads a row of an hdf5 data matrix and store it as Data</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#simnibs.msh.NodeData.summary" title="simnibs.msh.NodeData.summary"><code class="xref py py-obj docutils literal notranslate"><span class="pre">summary</span></code></a>([percentiles,&nbsp;focality_cutoffs,&nbsp;units])</td>
<td>Creates a text summaty of the field</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#simnibs.msh.NodeData.tangent" title="simnibs.msh.NodeData.tangent"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tangent</span></code></a>([fill])</td>
<td>Calculate the tangent component of the field in the surfaces</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#simnibs.msh.NodeData.to_deformed_grid" title="simnibs.msh.NodeData.to_deformed_grid"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_deformed_grid</span></code></a>(warp,&nbsp;reference[,&nbsp;out,&nbsp;…])</td>
<td>Interpolates field to a grid and apply non-linear interpolation</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#simnibs.msh.NodeData.to_nifti" title="simnibs.msh.NodeData.to_nifti"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_nifti</span></code></a>(n_voxels,&nbsp;affine[,&nbsp;fn,&nbsp;units,&nbsp;…])</td>
<td>Transforms the data in a nifti file</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#simnibs.msh.NodeData.view_options" title="simnibs.msh.NodeData.view_options"><code class="xref py py-obj docutils literal notranslate"><span class="pre">view_options</span></code></a>([v_range,&nbsp;percentile,&nbsp;visible,&nbsp;…])</td>
<td>Generates a View object with visualization opions</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#simnibs.msh.NodeData.write" title="simnibs.msh.NodeData.write"><code class="xref py py-obj docutils literal notranslate"><span class="pre">write</span></code></a>(fn)</td>
<td>Writes this NodeData field to a file with field information only This file needs to be merged with a mesh for visualization</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#simnibs.msh.NodeData.write_hdf5" title="simnibs.msh.NodeData.write_hdf5"><code class="xref py py-obj docutils literal notranslate"><span class="pre">write_hdf5</span></code></a>(hdf5_fn[,&nbsp;path])</td>
<td>Writes the field to an hdf5 file</td>
</tr>
</tbody>
</table>
<p class="rubric">Attributes</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#simnibs.msh.NodeData.indexing_nr" title="simnibs.msh.NodeData.indexing_nr"><code class="xref py py-obj docutils literal notranslate"><span class="pre">indexing_nr</span></code></a></td>
<td>Same as node_numbers</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#simnibs.msh.NodeData.node_number" title="simnibs.msh.NodeData.node_number"><code class="xref py py-obj docutils literal notranslate"><span class="pre">node_number</span></code></a></td>
<td>Node numbers (1, …, nr)</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#simnibs.msh.NodeData.nr" title="simnibs.msh.NodeData.nr"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nr</span></code></a></td>
<td>Number of data entries</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#simnibs.msh.NodeData.nr_comp" title="simnibs.msh.NodeData.nr_comp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nr_comp</span></code></a></td>
<td>Number of field components</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#simnibs.msh.NodeData.type" title="simnibs.msh.NodeData.type"><code class="xref py py-obj docutils literal notranslate"><span class="pre">type</span></code></a></td>
<td>NodeData of ElementData</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="simnibs.msh.NodeData.angle">
<code class="descname">angle</code><span class="sig-paren">(</span><em>fill=nan</em><span class="sig-paren">)</span><a class="headerlink" href="#simnibs.msh.NodeData.angle" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the angle between the field and the surface normal</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>fill</strong> (<em>float</em><em> (</em><em>optional</em><em>)</em>) – Value to be used when node is not in surface</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>angle</strong> – NodeData field with the angles the field where a surface is defined and the
fill value where it’s not</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#simnibs.msh.NodeData" title="simnibs.msh.NodeData">NodeData</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="simnibs.msh.NodeData.append_to_mesh">
<code class="descname">append_to_mesh</code><span class="sig-paren">(</span><em>fn</em>, <em>mode='binary'</em><span class="sig-paren">)</span><a class="headerlink" href="#simnibs.msh.NodeData.append_to_mesh" title="Permalink to this definition">¶</a></dt>
<dd><p>Appends this NodeData fields to a file</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>fn</strong> (<em>str</em>) – file name</li>
<li><strong>mode</strong> (<em>binary</em><em> or </em><em>ascii</em>) – mode in which to write</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="simnibs.msh.NodeData.as_nodedata">
<code class="descname">as_nodedata</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#simnibs.msh.NodeData.as_nodedata" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="simnibs.msh.NodeData.calc_flux">
<code class="descname">calc_flux</code><span class="sig-paren">(</span><em>nodes=None</em><span class="sig-paren">)</span><a class="headerlink" href="#simnibs.msh.NodeData.calc_flux" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the flux of a vector field though the given nodes</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>nodes</strong> (<em>list of ints</em>) – List of node indices where to calculate flux. Default: all nodes in triangle
surface</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>flux</strong> – Total fux through all surfcaces</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">float</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="simnibs.msh.NodeData.get_focality">
<code class="descname">get_focality</code><span class="sig-paren">(</span><em>cuttofs=[50, 70], peak_percentile=99.9</em><span class="sig-paren">)</span><a class="headerlink" href="#simnibs.msh.NodeData.get_focality" title="Permalink to this definition">¶</a></dt>
<dd><p>Caluclates field focality as the area/volume of the mesh experiencing a field
norm of above (cut_off% of the field peak). peak_percentile gives what is the
field peak</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>cuttofs</strong> (<em>ndarray</em><em> (</em><em>optional</em><em>)</em>) – Percentage of the peak value for the cut_off, between 0 and 100. Default: [50, 70]</li>
<li><strong>peak_percentile</strong> (<em>float</em><em> (</em><em>optional</em><em>)</em>) – Percentile to be used to calculate peak value. Default: 99.9</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>focality</strong> – Area/volume exceeding the cuttof of the peak value</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">ndarray</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="simnibs.msh.NodeData.get_percentiles">
<code class="descname">get_percentiles</code><span class="sig-paren">(</span><em>percentile=[99.9], roi=None</em><span class="sig-paren">)</span><a class="headerlink" href="#simnibs.msh.NodeData.get_percentiles" title="Permalink to this definition">¶</a></dt>
<dd><p>Get percentiles of field (or field norm, if a vector field)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>percentile</strong> (<em>ndarray</em><em> (</em><em>optional</em><em>)</em>) – Percentiles of interest, between 0 and 100. Defaut: 99.9</li>
<li><strong>roi</strong> (<em>ndarray</em><em> (</em><em>optinal</em><em>)</em>) – Region of interest in terms of element/node indices. Default: the whole mesh</li>
<li><strong>Returnts</strong> – </li>
<li><strong>----------</strong> – </li>
<li><strong>f_p</strong> (<em>ndarray</em>) – Field at the given percentiles</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="simnibs.msh.NodeData.gradient">
<code class="descname">gradient</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#simnibs.msh.NodeData.gradient" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the gradient of a field in the middle of the tetrahedra</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>mesh</strong> (<em>simnibs.Msh</em>) – A mesh with the geometrical information</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>grad</strong> – An ElementData field with gradient in the middle of each tetrahedra</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">simnibs.ElementData</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="simnibs.msh.NodeData.indexing_nr">
<code class="descname">indexing_nr</code><a class="headerlink" href="#simnibs.msh.NodeData.indexing_nr" title="Permalink to this definition">¶</a></dt>
<dd><p>Same as node_numbers</p>
</dd></dl>

<dl class="method">
<dt id="simnibs.msh.NodeData.interpolate_scattered">
<code class="descname">interpolate_scattered</code><span class="sig-paren">(</span><em>points</em>, <em>out_fill=nan</em>, <em>squeeze=True</em><span class="sig-paren">)</span><a class="headerlink" href="#simnibs.msh.NodeData.interpolate_scattered" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpolates the NodeaData into the points by finding the element
containing the point and performing linear interpolation inside the element</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>points</strong> (<em>Nx3 ndarray</em>) – List of points where we want to interpolate</li>
<li><strong>out_fill</strong> (<em>float</em>) – Value to be goven to points outside the volume. If ‘nearest’, will assign the
value of th nearest node. (default: NaN)</li>
<li><strong>squeeze</strong> (<em>bool</em>) – Wether to squeeze the output. Default: True</li>
<li><strong>Returns</strong> – </li>
<li><strong>----</strong> – </li>
<li><strong>f</strong> (<em>np.ndarray</em>) – Value of function in the points</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="simnibs.msh.NodeData.interpolate_to_grid">
<code class="descname">interpolate_to_grid</code><span class="sig-paren">(</span><em>n_voxels</em>, <em>affine</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#simnibs.msh.NodeData.interpolate_to_grid" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Interpolates the NodeData into a grid.</dt>
<dd>finds which tetrahedra contais the given voxel and
performs linear interpolation inside the voxel</dd>
</dl>
<p>The kwargs is ony to have the same interface as the ElementData version</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>n_voxels</strong> (<em>list</em><em> or </em><em>tuple</em>) – number of voxels in x, y, and z directions</li>
<li><strong>affine</strong> (<em>ndarray</em>) – A 4x4 matrix specifying the transformation from voxels to xyz</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>image</strong> – An (n_voxels[0], n_voxels[1], n_voxels[2], nr_comp) matrix with
interpolated values. If nr_comp == 1, the last dimension is squeezed out</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">ndarray</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="simnibs.msh.NodeData.interpolate_to_surface">
<code class="descname">interpolate_to_surface</code><span class="sig-paren">(</span><em>surface</em>, <em>out_fill='nearest'</em><span class="sig-paren">)</span><a class="headerlink" href="#simnibs.msh.NodeData.interpolate_to_surface" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpolates the field in the nodes of a given surface
The interpolation occurs in the tetrahedra!</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>surface</strong> (<a class="reference internal" href="simnibs.msh.Msh.html#simnibs.msh.Msh" title="simnibs.msh.Msh"><em>Msh</em></a>) – Mesh structure with triangles only</li>
<li><strong>out_fill</strong> (<em>float</em><em> or </em><em>'nearest'</em><em> (</em><em>optional</em><em>)</em>) – Value to be assigned to the points in the surface outside the volume.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>node_data</strong> – Node data structure with the interpolated field</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#simnibs.msh.NodeData" title="simnibs.msh.NodeData">NodeData</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="simnibs.msh.NodeData.mean_field_norm">
<code class="descname">mean_field_norm</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#simnibs.msh.NodeData.mean_field_norm" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates V*w/sum(w)
Where V is the norm of the field, and w is the volume or area of the mesh where
the field is defined. This can be used as a focality metric. It should give out
small values when the field is focal and</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>eff_area</strong> – Area or volume of mesh, weighted by the field</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">float</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="simnibs.msh.NodeData.node_data2elm_data">
<code class="descname">node_data2elm_data</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#simnibs.msh.NodeData.node_data2elm_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Transforms an ElementData field into a NodeData field
the value in the element is the average of the value in the nodes</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">structure with field value interpolated at element centers</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">simnibs.ElementData</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt>
<code class="descname">node_number</code></dt>
<dd><p>Node numbers (1, …, nr)</p>
</dd></dl>

<dl class="method">
<dt id="simnibs.msh.NodeData.norm">
<code class="descname">norm</code><span class="sig-paren">(</span><em>ord=2</em><span class="sig-paren">)</span><a class="headerlink" href="#simnibs.msh.NodeData.norm" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the norm of the field</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>ord</strong> (<em>float</em>) – Order of norm. Default: 2 (euclidian norm)</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>norm</strong> – NodeData field with the norm the field</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#simnibs.msh.NodeData" title="simnibs.msh.NodeData">NodeData</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="simnibs.msh.NodeData.normal">
<code class="descname">normal</code><span class="sig-paren">(</span><em>fill=nan</em><span class="sig-paren">)</span><a class="headerlink" href="#simnibs.msh.NodeData.normal" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the normal component of the field in the mesh surfaces</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>fill</strong> (<em>float</em><em> (</em><em>optional</em><em>)</em>) – Value to be used when node is not in surface (Default: NaN)</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>normal</strong> – NodeData field with the normal the field where a surface is defined and the
fill value where it’s not</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#simnibs.msh.NodeData" title="simnibs.msh.NodeData">NodeData</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt>
<code class="descname">nr</code></dt>
<dd><p>Number of data entries</p>
</dd></dl>

<dl class="attribute">
<dt>
<code class="descname">nr_comp</code></dt>
<dd><p>Number of field components</p>
</dd></dl>

<dl class="classmethod">
<dt id="simnibs.msh.NodeData.read_hdf5_data_matrix_row">
<em class="property">classmethod </em><code class="descname">read_hdf5_data_matrix_row</code><span class="sig-paren">(</span><em>leadfield_fn</em>, <em>field_name</em>, <em>row</em><span class="sig-paren">)</span><a class="headerlink" href="#simnibs.msh.NodeData.read_hdf5_data_matrix_row" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads a row of an hdf5 data matrix and store it as Data</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>leadfield_fn</strong> (<em>str</em>) – Name of file with leadfield</li>
<li><strong>field_name</strong> (<em>str</em>) – name of field</li>
<li><strong>row</strong> (<em>int</em>) – number of the row to be read</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>data</strong> – instance with the fields</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">Data()</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="simnibs.msh.NodeData.summary">
<code class="descname">summary</code><span class="sig-paren">(</span><em>percentiles=(99.9</em>, <em>99</em>, <em>95)</em>, <em>focality_cutoffs=(75</em>, <em>50)</em>, <em>units=None</em><span class="sig-paren">)</span><a class="headerlink" href="#simnibs.msh.NodeData.summary" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a text summaty of the field</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>percentiles</strong> (<em>ndarray</em><em> (</em><em>optinal</em><em>)</em>) – Field percentiles to be printed. Default: (99.9, 99, 95)</li>
<li><strong>focality_cutoffs</strong> (<em>ndarray</em><em> (</em><em>optional</em><em>)</em>) – Cuttofs for focality calculations. Default: (75, 50)</li>
<li><strong>units</strong> (<em>str</em><em> or </em><em>None</em>) – Name of field units or automatically determine from name</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="simnibs.msh.NodeData.tangent">
<code class="descname">tangent</code><span class="sig-paren">(</span><em>fill=nan</em><span class="sig-paren">)</span><a class="headerlink" href="#simnibs.msh.NodeData.tangent" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the tangent component of the field in the surfaces</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>fill</strong> (<em>float</em><em> (</em><em>optional</em><em>)</em>) – Value to be used when node is not in surface</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>tangent</strong> – NodeData field with the tangent component of the field where a surface is defined and the
fill value where it’s not</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#simnibs.msh.NodeData" title="simnibs.msh.NodeData">NodeData</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="simnibs.msh.NodeData.to_deformed_grid">
<code class="descname">to_deformed_grid</code><span class="sig-paren">(</span><em>warp</em>, <em>reference</em>, <em>out=None</em>, <em>out_original=None</em>, <em>tags=None</em>, <em>order=3</em>, <em>method='linear'</em>, <em>continuous=False</em>, <em>inverse_warp=None</em>, <em>reference_original=None</em>, <em>binary=False</em><span class="sig-paren">)</span><a class="headerlink" href="#simnibs.msh.NodeData.to_deformed_grid" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpolates field to a grid and apply non-linear interpolation</p>
<p>We first interpolate to a grid and then apply the transformation in order to
avoid problems from deformed triangles</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>warp</strong> (<em>str</em>) – Name of file with the transformation. Can either be a nifti file
where each voxel corresponds to coordinates (x, y, z) in the original space
or an affine transformation defined from the target space to the original
space. In the later case, the name must finish in “.mat”, and it will be read
with the numpy loadtxt file</li>
<li><strong>ref</strong> (<em>str</em>) – Name of reference file. The output will be in the same space
as the reference (same affine transfomation and same dimensions)</li>
<li><strong>out</strong> (<em>str</em><em> (</em><em>optional</em><em>)</em>) – If not None, the result will be written to this file as a nifti</li>
<li><strong>out_original</strong> (<em>str</em><em> (</em><em>optional</em><em>)</em>) – If not None, the volume in the original grid be written to this file as a nifti</li>
<li><strong>tags</strong> (<em>list</em><em> (</em><em>options</em><em>)</em>) – Mesh tags to be transformed. Defaut: transform the entire mesh</li>
<li><strong>order</strong> (<em>int</em>) – Interpolation order to be used</li>
<li><strong>method</strong> (<em>{'assign'</em><em> or </em><em>'linear'}</em><em> (</em><em>Optional</em><em>)</em>) – Method for gridding the data.
If ‘assign’, gives to each voxel the value of the element that contains
it. If linear, first assign fields to nodes, and then perform
baricentric interpolatiom. Only for ElementData input. Default: linear</li>
<li><strong>continuous</strong> (<em>bool</em>) – Wether fields is continuous across tissue boundaries. Changes the
behaviour of the function only if method == ‘linear’. Default: False</li>
<li><strong>inverse_warp</strong> (<em>str</em>) – Name of nifti file with inverse the transformation. Used to rotate vectors to the
target space in the case of non-liner transformations. If the transformation is
linear, the inverse matrix is used.</li>
<li><strong>reference_original</strong> (<em>str</em>) – Name of nifti file with reference in the original space. Used to determine
the dimensions and affine transformation for the initial griding</li>
<li><strong>Returns</strong> – </li>
<li><strong>--------</strong> – </li>
<li><strong>img</strong> (<em>nibabel.Nifti1Pair</em>) – Nibabel image object with tranformed field</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="simnibs.msh.NodeData.to_nifti">
<code class="descname">to_nifti</code><span class="sig-paren">(</span><em>n_voxels</em>, <em>affine</em>, <em>fn=None</em>, <em>units='mm'</em>, <em>qform=None</em>, <em>method='linear'</em>, <em>continuous=False</em><span class="sig-paren">)</span><a class="headerlink" href="#simnibs.msh.NodeData.to_nifti" title="Permalink to this definition">¶</a></dt>
<dd><p>Transforms the data in a nifti file</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>n_voxels</strong> (<em>list of ints</em>) – Number of vexels in each dimension</li>
<li><strong>affine</strong> (<em>4x4 ndarray</em>) – Transformation of voxel space into xyz. This sets the sform</li>
<li><strong>fn</strong> (<em>str</em><em> (</em><em>optional</em><em>)</em>) – String with file name to be used, if the result is to be saved</li>
<li><strong>units</strong> (<em>str</em><em> (</em><em>optional</em><em>)</em>) – Units to be set in the NifTI header. Default: mm</li>
<li><strong>qform</strong> (<em>4x4 ndarray</em><em> (</em><em>optional</em><em>)</em>) – Header qform. Default: set the same as the affine</li>
<li><strong>method</strong> (<em>{'assign'</em><em> or </em><em>'linear'}</em><em> (</em><em>Optional</em><em>)</em>) – If ‘assign’, gives to each voxel the value of the element that contains
it. If linear, first assign fields to nodes, and then perform
baricentric interpolatiom. Only for ElementData input. Default: linear</li>
<li><strong>continuous</strong> (<em>bool</em>) – Wether fields is continuous across tissue boundaries. Changes the
behaviour of the function only if method == ‘linear’. Default: False</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>img</strong> – Image object with the field interpolated in the voxels</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">nibabel.Nifti1Pair</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="simnibs.msh.NodeData.type">
<code class="descname">type</code><a class="headerlink" href="#simnibs.msh.NodeData.type" title="Permalink to this definition">¶</a></dt>
<dd><p>NodeData of ElementData</p>
</dd></dl>

<dl class="method">
<dt id="simnibs.msh.NodeData.view_options">
<code class="descname">view_options</code><span class="sig-paren">(</span><em>v_range='auto'</em>, <em>percentile=False</em>, <em>visible=True</em>, <em>visible_tags=None</em>, <em>saturate=True</em>, <em>idx=None</em><span class="sig-paren">)</span><a class="headerlink" href="#simnibs.msh.NodeData.view_options" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a View object with visualization opions</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>v_range</strong> (<em>[</em><em>min</em><em>, </em><em>max</em><em>] or </em><em>'auto'</em><em> (</em><em>optional</em><em>)</em>) – Range of the values to be displayed. Defaut: will automatically try to find a
good range (0.1 - 99.9% percentile for positive or vector data, symetrical
for two-sided data)</li>
<li><strong>percentile</strong> (<em>bool</em><em> (</em><em>optional</em><em>)</em>) – Whether the values in v_range arre given in percentile (between 0 and 100).
Default: False</li>
<li><strong>visible</strong> (<em>bool</em><em> (</em><em>optional</em><em>)</em>) – Whether to turn on visualization of this field. Default: True</li>
<li><strong>visible_tags</strong> (<em>list</em><em> (</em><em>optional</em><em>)</em>) – List of tags to be visible. Will also be used to calulate field ranges in
‘auto’ mode or if percentile=True. Default: all tags</li>
<li><strong>saturate</strong> (<em>bool</em><em> (</em><em>optional</em><em>)</em>) – Whether to saturate values. Default: true</li>
<li><strong>idx</strong> (<em>int</em><em> (</em><em>optional</em><em>)</em>) – Index of this field in the mesh</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>view</strong> – view object</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">gmsh_visualization.View</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="simnibs.msh.NodeData.write">
<code class="descname">write</code><span class="sig-paren">(</span><em>fn</em><span class="sig-paren">)</span><a class="headerlink" href="#simnibs.msh.NodeData.write" title="Permalink to this definition">¶</a></dt>
<dd><p>Writes this NodeData field to a file with field information only
This file needs to be merged with a mesh for visualization</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>fn</strong> (<em>str</em>) – file name</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="simnibs.msh.NodeData.write_hdf5">
<code class="descname">write_hdf5</code><span class="sig-paren">(</span><em>hdf5_fn</em>, <em>path='./'</em><span class="sig-paren">)</span><a class="headerlink" href="#simnibs.msh.NodeData.write_hdf5" title="Permalink to this definition">¶</a></dt>
<dd><p>Writes the field to an hdf5 file</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>hdf5_fn</strong> (<em>str</em>) – file name of hdf5 file</li>
<li><strong>path</strong> (<em>str</em>) – path in the hdf5 file where the field should be saved</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../index.html">SimNIBS</a></h1>








<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorial/tutorial.html">Tutorial</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../../documentation.html">Documentation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../../gui.html">Graphical User Interface Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../command_line/command_line.html">Command Line Tools</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../sim_struct/sim_struct.html">Simulation Data Structures</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../file_formats.html">File Formats in SimNIBS</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../coordinates.html">Coordinates in SimNIBS</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../conductivity.html">Standard Conductivity Values</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../coils.html">Coil Models Included in SimNIBS</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../python_lib.html">Python Library Documentation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../contributors.html">Contributors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../publications.html">Publications</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../changelog.html">Changelog</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../documentation.html">Documentation</a><ul>
  <li><a href="../python_lib.html">Python Library Documentation</a><ul>
  <li><a href="../msh.html">simnibs.msh</a><ul>
      <li>Previous: <a href="simnibs.msh.Elements.html" title="previous chapter">simnibs.msh.Elements</a></li>
      <li>Next: <a href="simnibs.msh.ElementData.html" title="next chapter">simnibs.msh.ElementData</a></li>
  </ul></li>
  </ul></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2019, SimNIBS Developers.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.8.5</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../../../_sources/documentation/python_lib/auto/simnibs.msh.NodeData.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>